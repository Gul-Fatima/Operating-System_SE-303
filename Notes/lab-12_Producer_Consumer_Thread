import threading
import time
import random
from collections import deque

# --- Configuration ---
BUFFER_SIZE = 5
PRODUCER_COUNT = 2
CONSUMER_COUNT = 3

# --- Shared Resources ---
buffer = deque(maxlen=BUFFER_SIZE)

# --- Synchronization Primitives ---
empty = threading.Semaphore(BUFFER_SIZE)  # Tracks empty slots
full = threading.Semaphore(0)             # Tracks filled slots
mutex = threading.Lock()                  # Mutual exclusion

# --- Producer Thread ---
def producer(producer_id):
    global buffer
    item_counter = 0
    while True:
        item = f"Item-{producer_id}-{item_counter}"

        # 1. Wait for empty slot
        empty.acquire()

        # 2. Lock buffer for exclusive access
        mutex.acquire()

        # --- PRODUCE ---
        time.sleep(random.uniform(0.5, 2))
        buffer.append(item)
        print(f"Producer {producer_id} produced {item}. Buffer: {list(buffer)}")

        # 3. Unlock buffer
        mutex.release()

        # 4. Signal that buffer now has one more full slot
        full.release()

        item_counter += 1


# --- Consumer Thread ---
def consumer(consumer_id):
    global buffer
    while True:

        # 1. Wait for available item
        full.acquire()

        # 2. Acquire lock
        mutex.acquire()

        # --- CONSUME ---
        item = buffer.popleft()
        print(f"Consumer {consumer_id} consumed {item}. Buffer: {list(buffer)}")

        # 3. Release lock
        mutex.release()

        # 4. Signal that a slot is now empty
        empty.release()

        # Simulate time taken to consume
        time.sleep(random.uniform(1, 3))


# --- Main Application ---
if __name__ == "__main__":
    threads = []

    # Create and start producer threads
    for i in range(PRODUCER_COUNT):
        thread = threading.Thread(target=producer, args=(i,))
        threads.append(thread)
        thread.start()

    # Create and start consumer threads
    for i in range(CONSUMER_COUNT):
        thread = threading.Thread(target=consumer, args=(i,))
        threads.append(thread)
        thread.start()

    # Join threads (not reachable due to infinite loop)
    for thread in threads:
        thread.join()

